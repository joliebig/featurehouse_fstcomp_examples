/* Generated By:JavaCC: Do not edit this line. BaliParser.java */

public class BaliParser implements BaliParserConstants {

    private static BaliParse parseRoot = null ;

    public static BaliParse getStartRoot () {
        return parseRoot ;
    }

    public static BaliParse getStartRoot (BaliParser parser)
    throws ParseException {
        try {
            parseRoot = parser.BaliParse () ;
            parser.requireEOF () ;
            return parseRoot ;
        } catch (TokenMgrError error) {
            ParseException e = new ParseException
            ("token error occurred") ;
            e.initCause (error) ;
            throw e ;
        }
    }

    // Wraps an optional node around an AstNode:
    //
    static AstOptNode opt (AstNode node) {
        return new AstOptNode () . setParms (node) ;
    }

    // Wraps an optional node around an AstToken:
    //
    static AstOptToken opt (AstToken token) {
        return new AstOptToken () . setParms (token) ;
    }

    // Forces an end-of-file check in the tokenStream:
    //
    public void requireEOF () throws ParseException {
        try {
            jj_consume_token (BaliParserConstants.EOF) ;
        } catch (TokenMgrError error) {
            ParseException e = new ParseException ("EOF error") ;
            e.initCause (error) ;
            throw e ;
        }
    }

    // Converts a JavaCC Token to a Bali AstToken:
    //
    static AstToken t2at (Token tok) {

        // Special case -- if token is optional:
        //
        if (tok == null)
            return (null) ;

        StringBuffer buffer = new StringBuffer () ;
        Token special = tok.specialToken;
        while (special != null) {
            buffer.insert (0, special.toString()) ;
            special = special.specialToken ;
        }
        String white = buffer.toString () ;

        return new AstToken().setParms (white, tok.image, tok.endLine) ;
    }

    //*************************************************************************
    // Code inserted from "bali.b" source grammar:
    //*************************************************************************

    /**
     * Append the given {@link Token} and any preceding special tokens to a
     * given {@link StringBuffer}.
     *
     * @param token the given JavaCC {@link Token} object
     * @param buffer the buffer to which to append <code>token</code>
     **/
    final private static void accumulate (Token token, StringBuffer buffer) {

        // Append preceding special tokens to <code>buffer</code>:
        //
        Token special = firstSpecial (token) ;
        if (special != token)
            while (special != null) {
                buffer.append (special.toString ()) ;
                special = special.next ;
            }

        // Finally, append the token itself:
        //
        buffer.append (token.toString ()) ;
    }

    /**
     * Accumulate {@list Token} objects from the token stream, respecting
     * nested code inside <code>open</code> and <code>close</code> pairs,
     * until an unmatched <code>close</code> is the next token in the stream.
     * This method assumes that an <code>open</code> token has just been read
     * from the stream so the initial nesting level is 1.  The method returns
     * when a matching <code>close</code> token is the next token in the token
     * stream.  <em>The <code>close</code> token is left in the stream!</em>
     *
     * @return the accumulated tokens as a {@link String}.
     *
     * @throws ParseException
     * if an end-of-file is found before an unmatched <code>close</code> token.
     **/
    final private Token accumulateNestedRegion (int open, int close)
    throws ParseException {

        StringBuffer buffer = new StringBuffer () ;

        // Initialize result with known information (starting position, etc.):
        //
        Token result = Token.newToken (OTHER) ;
        result.specialToken = null ;

        Token startToken = firstSpecial (getToken (1)) ;
        result.beginColumn = startToken.beginColumn ;
        result.beginLine = startToken.beginLine ;

        // Accumulate tokens until a <code>close</code> token is found:
        //
        for (int nesting = 1 ; nesting > 0 ; ) {

            token = getToken (1) ;

            // Update information in result:
            //
            result.endColumn = token.endColumn ;
            result.endLine = token.endLine ;
            result.next = token.next ;

            if (token.kind == EOF)
                throw new ParseException (
                    "accumulating from line "
                    + result.beginLine
                    + " at column "
                    + result.beginColumn
                    + ": EOF reached before ending "
                    + tokenImage [close]
                    + " found"
                ) ;

            if (token.kind == open)
                ++ nesting ;
            else if (token.kind == close) {
                if (nesting == 1)
                    break ;
                -- nesting ;
            }

            accumulate (token, buffer) ;
            getNextToken () ;
        }

        result.image = buffer.toString () ;
        return result ;
    }

    /**
     * Accumulate {@link Token} objects from the token stream until a token
     * matching <code>tokenKind</code> is consumed from the stream.  The
     * tokens are accumulated in <code>buffer</code>, including the terminating
     * token.
     *
     * @return a {@link Token}
     * formed by concatenating all intervening tokens and special tokens.
     **/
    final private Token accumulateUntilToken (int tokenKind)
    throws ParseException {

        StringBuffer buffer = new StringBuffer () ;
        Token token = getNextToken () ;

        // Initialize result with known information (starting position, etc.):
        //
        Token result = Token.newToken (OTHER) ;
        result.specialToken = null ;

        Token startToken = firstSpecial (token) ;
        result.beginColumn = startToken.beginColumn ;
        result.beginLine = startToken.beginLine ;

        // Accumulate tokens until a <code>tokenKind</code> token is found:
        //
        while (token.kind != tokenKind) {

            // Update information in result:
            //
            result.endColumn = token.endColumn ;
            result.endLine = token.endLine ;
            result.next = token.next ;

            if (token.kind == EOF)
                throw new ParseException (
                    "from line "
                    + result.beginLine
                    + " at column "
                    + result.beginColumn
                    + ": EOF reached before "
                    + tokenImage [tokenKind]
                    + " found"
                ) ;

            accumulate (token, buffer) ;
            token = getNextToken () ;
        }

        accumulate (token, buffer) ;

        result.image = buffer.toString () ;
        return result ;
    }

    /**
     * Finds the first token, special or otherwise, in the list of special
     * tokens preceding this {@link Token}.  If this list is non-empty, the
     * result will be a special token.  Otherwise, it will be the starting
     * token.
     *
     * @param token the given {@link Token}.
     * @return the first special token preceding <code>token</code>.
     **/
    final private static Token firstSpecial (Token token) {

        while (token.specialToken != null)
            token = token.specialToken ;

        return token ;
    }

  CodeBlockNode codeBlockNode(Token token) throws ParseException {
    return (new CodeBlockNode ()) . setParms (t2at (token)) ;
  }

  CodeBlockNode findBlockBegin() throws ParseException {
    return codeBlockNode (accumulateUntilToken (LBRACE)) ;
  }

  CodeBlockNode findBlockEnd() throws ParseException {
    return codeBlockNode (accumulateNestedRegion (LBRACE, RBRACE)) ;
  }

  CodeBlockNode findCloseAngle() throws ParseException {
    return codeBlockNode (accumulateNestedRegion (OPENANGLE, CLOSEANGLE)) ;
  }

  CodeBlockNode findCloseParen() throws ParseException {
    return codeBlockNode (accumulateNestedRegion (OPENPAREN, CLOSEPAREN)) ;
  }

//-----------------------------------//
// Productions from Bali grammar:
//-----------------------------------//
  final public BaliParse BaliParse() throws ParseException {
    Options op0=null ;
    ParserCode pa0=null ;
    Statements st0=null ;
    switch (jj_nt.kind) {
    case _OPTIONS:
      op0 = Options();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case _CODE:
      pa0 = ParserCode();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case OPENANGLE:
    case _JAVACODE:
    case _MORE:
    case _REQUIRE:
    case _SKIP:
    case _SPECIAL_TOKEN:
    case _TOKEN:
    case _TOKEN_MGR_DECLS:
    case STRING:
    case IDENTIFIER:
      st0 = Statements();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
     {if (true) return new BaliParseNode().setParms (opt(op0), opt(pa0), opt(st0)) ;}
    throw new Error("Missing return statement in function");
  }

  final public AngleRegex AngleRegex() throws ParseException {
    ComplexRegex co0=null ;
    Label la0=null ;
    Token to1=null, to0=null ;
    if (jj_2_1(2)) {
      to0 = jj_consume_token(BALI_TOKEN);
      to1 = jj_consume_token(CLOSEANGLE);
     {if (true) return new BaliRegexNode().setParms (t2at(to0), t2at(to1)) ;}
    } else if (jj_2_2(2)) {
      switch (jj_nt.kind) {
      case BALI_TOKEN:
      case 45:
        la0 = Label();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      co0 = ComplexRegex();
     {if (true) return new ComplexRegexNode().setParms (opt(la0), co0) ;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BaliGrammarRule BaliGrammarRule() throws ParseException {
    Productions pr0=null ;
    Token to2=null, to1=null, to0=null ;
    to0 = jj_consume_token(IDENTIFIER);
    to1 = jj_consume_token(40);
    pr0 = Productions();
    to2 = jj_consume_token(41);
     {if (true) return new BaliGrammarNode().setParms
    (t2at(to0), t2at(to1), pr0, t2at(to2)) ;}
    throw new Error("Missing return statement in function");
  }

  final public BaliTokenDefinition BaliTokenDefinition() throws ParseException {
    Token to1=null, to0=null ;
    to0 = jj_consume_token(STRING);
    to1 = jj_consume_token(BALI_TOKEN);
     {if (true) return new BaliTokenDefineNode().setParms (t2at(to0), t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public Block Block() throws ParseException {
    CodeBlockNode co0=null ;
    Token to1=null, to0=null ;
    to0 = jj_consume_token(LBRACE);
    co0 = findBlockEnd();
    to1 = jj_consume_token(RBRACE);
     {if (true) return new BlockNode().setParms (t2at(to0), co0, t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public CaseFlag CaseFlag() throws ParseException {
    Token to2=null, to1=null, to0=null ;
    to0 = jj_consume_token(42);
    to1 = jj_consume_token(_IGNORE_CASE);
    to2 = jj_consume_token(43);
     {if (true) return new CaseFlagNode().setParms (t2at(to0), t2at(to1), t2at(to2)) ;}
    throw new Error("Missing return statement in function");
  }

  final public ClassName ClassName() throws ParseException {
    Token to1=null, to0=null ;
    to0 = jj_consume_token(44);
    to1 = jj_consume_token(IDENTIFIER);
     {if (true) return new ClassNameNode().setParms (t2at(to0), t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public ComplexRegex ComplexRegex() throws ParseException {
    CodeBlockNode co0=null ;
    Token to1=null, to0=null ;
    if (jj_2_3(2)) {
      to0 = jj_consume_token(STRING);
      to1 = jj_consume_token(CLOSEANGLE);
     {if (true) return new StringComplexNode().setParms (t2at(to0), t2at(to1)) ;}
    } else {
      co0 = findCloseAngle();
      to0 = jj_consume_token(CLOSEANGLE);
     {if (true) return new AngleComplexNode().setParms (co0, t2at(to0)) ;}
    }
    throw new Error("Missing return statement in function");
  }

  final public JavacodeProduction JavacodeProduction() throws ParseException {
    ScanBlock sc0=null ;
    Token to0=null ;
    to0 = jj_consume_token(_JAVACODE);
    sc0 = ScanBlock();
     {if (true) return new JavacodeNode().setParms (t2at(to0), sc0) ;}
    throw new Error("Missing return statement in function");
  }

  final public Label Label() throws ParseException {
    Token to2=null, to1=null, to0=null ;
    switch (jj_nt.kind) {
    case 45:
      to0 = jj_consume_token(45);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    to1 = jj_consume_token(BALI_TOKEN);
    to2 = jj_consume_token(40);
     {if (true) return new LabelNode().setParms (opt(t2at(to0)), t2at(to1), t2at(to2)) ;}
    throw new Error("Missing return statement in function");
  }

  final public Lookahead Lookahead() throws ParseException {
    CodeBlockNode co0=null ;
    Token to2=null, to1=null, to0=null ;
    to0 = jj_consume_token(_LOOKAHEAD);
    to1 = jj_consume_token(OPENPAREN);
    co0 = findCloseParen();
    to2 = jj_consume_token(CLOSEPAREN);
     {if (true) return new LookaheadNode().setParms
    (t2at(to0), t2at(to1), co0, t2at(to2)) ;}
    throw new Error("Missing return statement in function");
  }

  final public NextState NextState() throws ParseException {
    Token to1=null, to0=null ;
    to0 = jj_consume_token(40);
    to1 = jj_consume_token(BALI_TOKEN);
     {if (true) return new NextStateNode().setParms (t2at(to0), t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public Options Options() throws ParseException {
    Block bl0=null ;
    Token to1=null, to0=null ;
    to0 = jj_consume_token(_OPTIONS);
    bl0 = Block();
    to1 = jj_consume_token(_OPTIONS);
     {if (true) return new OptionsNode().setParms (t2at(to0), bl0, t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public ParserCode ParserCode() throws ParseException {
    Block bl0=null ;
    Token to1=null, to0=null ;
    to0 = jj_consume_token(_CODE);
    bl0 = Block();
    to1 = jj_consume_token(_CODE);
     {if (true) return new ParserCodeNode().setParms (t2at(to0), bl0, t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public Pattern Pattern() throws ParseException {
    Pattern list = new Pattern () ;
    Primitive pr0=null ;
    label_1:
    while (true) {
      pr0 = Primitive();
         list.add (new PatternElem().setParms (pr0)) ;
      switch (jj_nt.kind) {
      case BALI_TOKEN:
      case STRING:
      case 42:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_1;
      }
    }
     {if (true) return list ;}
    throw new Error("Missing return statement in function");
  }

  final public Primitive Primitive() throws ParseException {
    Lookahead lo0=null ;
    Terminal te0=null ;
    Token to1=null, to0=null ;
    switch (jj_nt.kind) {
    case 42:
      to0 = jj_consume_token(42);
      switch (jj_nt.kind) {
      case _LOOKAHEAD:
        lo0 = Lookahead();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      te0 = Terminal();
      to1 = jj_consume_token(43);
     {if (true) return new OptionalNode().setParms
    (t2at(to0), opt(lo0), te0, t2at(to1)) ;}
      break;
    case BALI_TOKEN:
    case STRING:
    case IDENTIFIER:
      te0 = Terminal();
     {if (true) return (Primitive) te0 ;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public PrimitiveRewrite PrimitiveRewrite() throws ParseException {
    ClassName cl0=null ;
    Lookahead lo0=null ;
    Pattern pa0=null ;
    Primitive pr1=null, pr0=null ;
    Token to2=null, to1=null, to0=null ;
    switch (jj_nt.kind) {
    case OPENPAREN:
      to0 = jj_consume_token(OPENPAREN);
      switch (jj_nt.kind) {
      case _LOOKAHEAD:
        lo0 = Lookahead();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      pr0 = Primitive();
      pr1 = Primitive();
      to1 = jj_consume_token(CLOSEPAREN);
      to2 = jj_consume_token(46);
     {if (true) return new ComplexListNode().setParms
    (t2at(to0), opt(lo0), pr0, pr1, t2at(to1), t2at(to2)) ;}
      break;
    default:
      jj_la1[11] = jj_gen;
      switch (jj_nt.kind) {
      case BALI_TOKEN:
      case STRING:
      case 42:
      case IDENTIFIER:
        pa0 = Pattern();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case 44:
        cl0 = ClassName();
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
     {if (true) return new PatternNode().setParms (opt(pa0), opt(cl0)) ;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Production Production() throws ParseException {
    Lookahead lo0=null ;
    Rewrite re0=null ;
    switch (jj_nt.kind) {
    case _LOOKAHEAD:
      lo0 = Lookahead();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    re0 = Rewrite();
     {if (true) return new ProductionNode().setParms (opt(lo0), re0) ;}
    throw new Error("Missing return statement in function");
  }

  final public Productions Productions() throws ParseException {
    Productions list = new Productions () ;
    Production pr0=null ;
    Token to0=null ;
    pr0 = Production();
     list.add (new ProductionsElem().setParms (pr0)) ;
    label_2:
    while (true) {
      switch (jj_nt.kind) {
      case 47:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_2;
      }
      to0 = jj_consume_token(47);
      pr0 = Production();
         list.add (new ProductionsElem().setParms (t2at(to0), pr0)) ;
    }
     {if (true) return list ;}
    throw new Error("Missing return statement in function");
  }

  final public REKind REKind() throws ParseException {
    Token to0=null ;
    switch (jj_nt.kind) {
    case _TOKEN:
      to0 = jj_consume_token(_TOKEN);
     {if (true) return new TokenKindNode().setParms (t2at(to0)) ;}
      break;
    case _SPECIAL_TOKEN:
      to0 = jj_consume_token(_SPECIAL_TOKEN);
     {if (true) return new SpecialKindNode().setParms (t2at(to0)) ;}
      break;
    case _SKIP:
      to0 = jj_consume_token(_SKIP);
     {if (true) return new SkipKindNode().setParms (t2at(to0)) ;}
      break;
    case _MORE:
      to0 = jj_consume_token(_MORE);
     {if (true) return new MoreKindNode().setParms (t2at(to0)) ;}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public REList REList() throws ParseException {
    REList list = new REList () ;
    RegexBlock re0=null ;
    Token to0=null ;
    re0 = RegexBlock();
     list.add (new REListElem().setParms (re0)) ;
    label_3:
    while (true) {
      switch (jj_nt.kind) {
      case 47:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_3;
      }
      to0 = jj_consume_token(47);
      re0 = RegexBlock();
         list.add (new REListElem().setParms (t2at(to0), re0)) ;
    }
     {if (true) return list ;}
    throw new Error("Missing return statement in function");
  }

  final public Regex Regex() throws ParseException {
    AngleRegex an0=null ;
    Token to0=null ;
    switch (jj_nt.kind) {
    case STRING:
      to0 = jj_consume_token(STRING);
     {if (true) return new StringRegexNode().setParms (t2at(to0)) ;}
      break;
    case OPENANGLE:
      to0 = jj_consume_token(OPENANGLE);
      an0 = AngleRegex();
     {if (true) return new AngleRegexNode().setParms (t2at(to0), an0) ;}
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public RegexBlock RegexBlock() throws ParseException {
    Block bl0=null ;
    NextState ne0=null ;
    Regex re0=null ;
    re0 = Regex();
    switch (jj_nt.kind) {
    case LBRACE:
      bl0 = Block();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case 40:
      ne0 = NextState();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
     {if (true) return new RegexBlockNode().setParms (re0, opt(bl0), opt(ne0)) ;}
    throw new Error("Missing return statement in function");
  }

  final public RegexTokenDefinition RegexTokenDefinition() throws ParseException {
    CaseFlag ca0=null ;
    REKind re0=null ;
    REList reSs0=null ;
    StateSet st0=null ;
    Token to2=null, to1=null, to0=null ;
    switch (jj_nt.kind) {
    case OPENANGLE:
      st0 = StateSet();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    re0 = REKind();
    switch (jj_nt.kind) {
    case 42:
      ca0 = CaseFlag();
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    to0 = jj_consume_token(40);
    to1 = jj_consume_token(LBRACE);
    reSs0 = REList();
    to2 = jj_consume_token(RBRACE);
     {if (true) return new RegexDefinitionNode().setParms
    (opt(st0), re0, opt(ca0), t2at(to0), t2at(to1), reSs0, t2at(to2)) ;}
    throw new Error("Missing return statement in function");
  }

  final public RequireRule RequireRule() throws ParseException {
    RequireType re0=null ;
    Token to0=null ;
    to0 = jj_consume_token(IDENTIFIER);
    switch (jj_nt.kind) {
    case 49:
      re0 = RequireType();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
     {if (true) return new RequireRuleNode().setParms (t2at(to0), opt(re0)) ;}
    throw new Error("Missing return statement in function");
  }

  final public RequireRules RequireRules() throws ParseException {
    RequireRules list = new RequireRules () ;
    RequireRule re0=null ;
    Token to0=null ;
    re0 = RequireRule();
     list.add (new RequireRulesElem().setParms (re0)) ;
    label_4:
    while (true) {
      switch (jj_nt.kind) {
      case 48:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_4;
      }
      to0 = jj_consume_token(48);
      re0 = RequireRule();
         list.add (new RequireRulesElem().setParms (t2at(to0), re0)) ;
    }
     {if (true) return list ;}
    throw new Error("Missing return statement in function");
  }

  final public RequireStatement RequireStatement() throws ParseException {
    RequireRules re0=null ;
    Token to1=null, to0=null ;
    to0 = jj_consume_token(_REQUIRE);
    re0 = RequireRules();
    to1 = jj_consume_token(41);
     {if (true) return new RequireStatementNode().setParms (t2at(to0), re0, t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public RequireType RequireType() throws ParseException {
    Token to1=null, to0=null ;
    to0 = jj_consume_token(49);
    to1 = jj_consume_token(IDENTIFIER);
     {if (true) return new RequireTypeNode().setParms (t2at(to0), t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public Rewrite Rewrite() throws ParseException {
    Lookahead lo0=null ;
    Primitive pr0=null ;
    PrimitiveRewrite prSs0=null ;
    Token to2=null, to1=null, to0=null ;
    switch (jj_nt.kind) {
    case OPENPAREN:
      to0 = jj_consume_token(OPENPAREN);
      switch (jj_nt.kind) {
      case _LOOKAHEAD:
        lo0 = Lookahead();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      pr0 = Primitive();
      to1 = jj_consume_token(CLOSEPAREN);
      to2 = jj_consume_token(50);
     {if (true) return new SimpleListNode().setParms
    (t2at(to0), opt(lo0), pr0, t2at(to1), t2at(to2)) ;}
      break;
    case BALI_TOKEN:
    case STRING:
    case 42:
    case IDENTIFIER:
      pr0 = Primitive();
      prSs0 = PrimitiveRewrite();
     {if (true) return new PrimitiveRewriteNode().setParms (pr0, prSs0) ;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ScanBlock ScanBlock() throws ParseException {
    CodeBlockNode co1=null, co0=null ;
    Token to0=null ;
    co0 = findBlockBegin();
    co1 = findBlockEnd();
    to0 = jj_consume_token(RBRACE);
     {if (true) return new ScanBlockNode().setParms (co0, co1, t2at(to0)) ;}
    throw new Error("Missing return statement in function");
  }

  final public StateName StateName() throws ParseException {
    Token to0=null ;
    to0 = jj_consume_token(BALI_TOKEN);
     {if (true) return new StateNameNode().setParms (t2at(to0)) ;}
    throw new Error("Missing return statement in function");
  }

  final public StateSet StateSet() throws ParseException {
    StatesSpecifier st0=null ;
    Token to1=null, to0=null ;
    to0 = jj_consume_token(OPENANGLE);
    st0 = StatesSpecifier();
    to1 = jj_consume_token(CLOSEANGLE);
     {if (true) return new StatesNode().setParms (t2at(to0), st0, t2at(to1)) ;}
    throw new Error("Missing return statement in function");
  }

  final public Statement Statement() throws ParseException {
    BaliGrammarRule ba0=null ;
    BaliTokenDefinition baSs0=null ;
    JavacodeProduction ja0=null ;
    RegexTokenDefinition reXv0=null ;
    RequireStatement re0=null ;
    TokenManagerDeclarations to0=null ;
    switch (jj_nt.kind) {
    case _REQUIRE:
      re0 = RequireStatement();
     {if (true) return (Statement) re0 ;}
      break;
    case IDENTIFIER:
      ba0 = BaliGrammarRule();
     {if (true) return (Statement) ba0 ;}
      break;
    case STRING:
      baSs0 = BaliTokenDefinition();
     {if (true) return (Statement) baSs0 ;}
      break;
    case _JAVACODE:
      ja0 = JavacodeProduction();
     {if (true) return (Statement) ja0 ;}
      break;
    case OPENANGLE:
    case _MORE:
    case _SKIP:
    case _SPECIAL_TOKEN:
    case _TOKEN:
      reXv0 = RegexTokenDefinition();
     {if (true) return (Statement) reXv0 ;}
      break;
    case _TOKEN_MGR_DECLS:
      to0 = TokenManagerDeclarations();
     {if (true) return (Statement) to0 ;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Statements Statements() throws ParseException {
    Statements list = new Statements () ;
    Statement st0=null ;
    label_5:
    while (true) {
      st0 = Statement();
         list.add (new StatementsElem().setParms (st0)) ;
      switch (jj_nt.kind) {
      case OPENANGLE:
      case _JAVACODE:
      case _MORE:
      case _REQUIRE:
      case _SKIP:
      case _SPECIAL_TOKEN:
      case _TOKEN:
      case _TOKEN_MGR_DECLS:
      case STRING:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_5;
      }
    }
     {if (true) return list ;}
    throw new Error("Missing return statement in function");
  }

  final public StatesList StatesList() throws ParseException {
    StatesList list = new StatesList () ;
    StateName st0=null ;
    Token to0=null ;
    st0 = StateName();
     list.add (new StatesListElem().setParms (st0)) ;
    label_6:
    while (true) {
      switch (jj_nt.kind) {
      case 48:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_6;
      }
      to0 = jj_consume_token(48);
      st0 = StateName();
         list.add (new StatesListElem().setParms (t2at(to0), st0)) ;
    }
     {if (true) return list ;}
    throw new Error("Missing return statement in function");
  }

  final public StatesSpecifier StatesSpecifier() throws ParseException {
    StatesList st0=null ;
    Token to0=null ;
    switch (jj_nt.kind) {
    case 46:
      to0 = jj_consume_token(46);
     {if (true) return new StarStatesNode().setParms (t2at(to0)) ;}
      break;
    case BALI_TOKEN:
      st0 = StatesList();
     {if (true) return new ListStatesNode().setParms (st0) ;}
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Terminal Terminal() throws ParseException {
    Token to0=null ;
    switch (jj_nt.kind) {
    case BALI_TOKEN:
      to0 = jj_consume_token(BALI_TOKEN);
     {if (true) return new BaliTokenNode().setParms (t2at(to0)) ;}
      break;
    case IDENTIFIER:
      to0 = jj_consume_token(IDENTIFIER);
     {if (true) return new IdentifierNode().setParms (t2at(to0)) ;}
      break;
    case STRING:
      to0 = jj_consume_token(STRING);
     {if (true) return new StringNode().setParms (t2at(to0)) ;}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TokenManagerDeclarations TokenManagerDeclarations() throws ParseException {
    ScanBlock sc0=null ;
    Token to1=null, to0=null ;
    to0 = jj_consume_token(_TOKEN_MGR_DECLS);
    to1 = jj_consume_token(40);
    sc0 = ScanBlock();
     {if (true) return new TokenManagerNode().setParms (t2at(to0), t2at(to1), sc0) ;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_3R_10() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(BALI_TOKEN)) return true;
    if (jj_scan_token(CLOSEANGLE)) return true;
    return false;
  }

  private boolean jj_3R_7() {
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(45)) jj_scanpos = xsp;
    if (jj_scan_token(BALI_TOKEN)) return true;
    if (jj_scan_token(40)) return true;
    return false;
  }

  private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) return true;
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(STRING)) return true;
    if (jj_scan_token(CLOSEANGLE)) return true;
    return false;
  }

  private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_7()) jj_scanpos = xsp;
    if (jj_3R_8()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public BaliParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x10000000,0x400000,0x8a080000,0x0,0x0,0x0,0x4000000,0x0,0x4000000,0x0,0x0,0x100000,0x4000000,0x0,0x8000000,0x0,0x80000,0x40000,0x0,0x80000,0x0,0x0,0x0,0x4000000,0x100000,0x8a080000,0x8a080000,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x8004f,0x2010,0x2000,0x80450,0x0,0x80450,0x0,0x80450,0x1000,0x0,0x0,0x8000,0x7,0x8000,0x40,0x0,0x100,0x0,0x400,0x20000,0x10000,0x0,0x80450,0x8004f,0x8004f,0x10000,0x4010,0x80050,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[3];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public BaliParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public BaliParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new BaliParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public BaliParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new BaliParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public BaliParser(BaliParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(BaliParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[53];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 53; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
