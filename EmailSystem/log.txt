23.09.2009:
meeting with sven. change of plans: since java architecture is growing more and more complex and time is running out because sven needs some c-code demo to integrate the validation tool, we switch over to a step-wise development, i.e. leaving software-architecture outside while trying very ad-hoc methods to implement at least some basic features and their interactions. Those are en-/decryption, signing/validation and forwarding.

26.09.2009:
decision:
encryption and signing are implemented ad flags being put in the emails message body before the original message body, e.g. [encrypted]. decryption works by scanning for that flag and removing it if possible. verification is analogous.
decision: encryption should be implemented by a basic but realistic encryption-algorithm instead of the flag.
    
28.09.2009:
implemented most features in client.c. still missing is a dynamic data-structure to grab mails reaching the mail and the delivered state. Implementation will be tricky since there are no native dynamich data structures in libc.
decision: emails reching the upon mentioned states will be put in a queue. test.c can access and grab the mails there to compare or print them e.g.
decision: email and email-queue should be put in seperate source-files for a better overview.

29.09.2009:
further work on the email queue. pointer arihmetics in c are a bit tricky.
question: what is the c-pendant to a field in java? every client should have exactly one email-queue.

30.09.2009:
finished a functional email queue. still work to to in organizing source code.
decision: capsulating email and email queue in source files containing struct(s) and methods. methods contain references to structs, i.e. myObject.myMethod() is here myClassMyMethod(myObject). forwarding also functional now.

01.10.2009:
began to write test-cases in a syntax "invented" on-the-fly. it's a mixture of pointcut-like statements as in aspectJ and boolean algebra.
problem: the modularity of features makes it difficult to determine the points in time when certain assertments should be true. here we can use the fact that the program terminates to grab those points, but in a distributed system it wouldn't be that easy, maybe it's not even possible to make assertions there.

15.10.2009:
skiped a few entries for the past days: restructured code to some sort of object oriented architecture as mentioned above. sven also introduced featureHouse to the c-part of the project.
today: tried the necessary functionality to extend structs: working. but the pre-processor annotations for singleton declaration of header-files won't work since the corresponding "#endif" is displaced from the end of the header file to somewhere in the middle. this behaviour is caused by the string concatenation in source files when composing features.

19.10.2009:
added "external include guards".
finally implemented Sign an Encrypt based on list. this list makes it possible to decide per receiver, whether to an a signature or encryption. this behaviour is needed for interactions 9 and 4.

26.10.2009:
made up some dfa's for beyers verification-tool. interactions 9, 27 and replacement of decrypt/verify should be covered by them. still to do: implement testing methods like isEncrypted or isReadable. have to talk to sven about this, since the MIME standard is more complex than i thought.
problem: in my understanding tests run by the verification tool still need test-scenarios which is bad since you have to create them manually.

27.10.2009:
read about MIME, decided to model encryption and signature more realistic, i.e. as extensions of email (additional fields like isEncrypted, encryptionKey). probably found a bug in fstcomposer: the return values of functions that should return pointers are messed up (* turns to **) when extending such a function using original().

30.11.2009:
problem occurred implementing addressBook feature: encrypt needs to clone emails per receiver, since the encryption is performed for a certain receiver only. addressBook therefore only has to add receivers in cc or bcc field, if more than one receiver is assigned to a nick.
trying to replace array-constructs containing more than one string to single-linked lists. there are such lists in Encrypt, Forward and AddressBook.

01.12.2009:
problem: includes are concatenated, so refinements can't access included code, since they appear further to the top than the include statements.

xxxx
changes in fstcomposer: include guards are generated now for every header-file, include-statements are placed on top of composed source-files. 

08.12.2009:
problem from 01.12.2009 appeared again in another form: when not including every function of a c-source-file in the corresponding header-file, there may be code that is accessed by the compiler before it is declared. possible workaround: including every function in header-file. not desireable since there may be functions you should not access directly from other source-files.

10.12.2009:
ag-meeting:
implement generative testing, i.e. no error-prone human generated test-cases.

14.12.2009:
Encrypt implies Keys
Decrypt implies Encrypt since it contains email refinements, e.g. a flag.

Sign implies Keys
Verify implies Sign since it contains email refinements, e.g. a flag.

16.12.2009:
messing around with encryption, decryption, sign and verify to reproduce the inconsistent-key scenarios.
idea: field for signature and encryption key that holds a key which is symmetric.
problem: transform inconsistent-key interactions into graphs

graph process
01-AddressBook-Encrypt: done
03-Sign-Verify: key problem, done
TODO 04-Sign-Forward: 
06-Encrypt-Decrypt: done
07-Encrypt-Verify: done
TODO 08-Encrypt-AutoResponder:
09-Encrypt-Forward: done
11-Decrypt-AutoResponder: key problem, covered through graph 06, done
27-Verify-Forward: done
Decrypt-Forward: done
